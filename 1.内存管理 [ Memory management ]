/*
|----------------------------------------
| Memory managerment
| @weiChen translate, <farwish@live.com>
| @MIT License
*/

### 内存管理基础 [ Basic memory management ]
  （中文doc）http://php.net/manual/zh/internals2.memory.management.php
  
  摘录：
   -----------------------------------------------------------------------------------------------------------------
  |                           主要的内存 APIs                                                                       |
  |-----------------------------------------------------------------------------------------------------------------|
  |       原型	                                    说明                                                            |
  |-----------------------------------------------------------------------------------------------------------------|
  | void *emalloc(size_t size)	                  分配 size 字节的内存。                                            |
  |-----------------------------------------------------------------------------------------------------------------|
  | void *ecalloc(size_t nmemb, size_t size)	    给 nmemb 元素分配 size 字节的缓冲区并初始化为零。                 |
  |-----------------------------------------------------------------------------------------------------------------|
  | void *erealloc(void *ptr, size_t size)	      修改使用 emalloc 分配的缓冲区 ptr 的大小为 size 字节。            |
  |-----------------------------------------------------------------------------------------------------------------|
  | void efree(void *ptr)	                        释放 ptr 指向的缓冲区。缓冲区必须是由 emalloc 分配的。            |
  |-----------------------------------------------------------------------------------------------------------------|
  | void *safe_emalloc(size_t nmemb, size_t size, size_t offset)	分配缓冲区来存放每块大小为 size 字节的 nmemb 块， |
  |                                                               并附加 offset 字节。                              |
  |                                                               类似于 emalloc(nmemb * size + offset)，           |
  |                                                               但增加了针对溢出的特殊保护。                      |
  |-----------------------------------------------------------------------------------------------------------------|
  | char *estrdup(const char *s)	                      分配一个可存放 NULL 结尾的字符串 s 的缓冲区，               |  
  |                                                     并将 s 复制到缓冲区内。                                     |
  |-----------------------------------------------------------------------------------------------------------------|
  | char *estrndup(const char *s, unsigned int length)	类似于 estrdup，但 NULL 结尾的字符串长度是已知的。          |
   -----------------------------------------------------------------------------------------------------------------
   
  Note: 和与 C 标准库相似的部分不同，如果分配请求的内存出错，Zend 引擎的内存管理函数不会返回 NULL 值，
  而会跳出并中止当前请求。
  
  
### 数据持久化 [ Data persistence ]
  http://php.net/manual/en/internals2.memory.persistence.php
  
  在这个上下文中，数据持久化的意思是任何想在当前请求中存活的数据。引擎内部的内存管理非常专注于请求绑定分配，
但这并不总是实用和合适的。持久内存有时是需要的为了满足外部库的要求，在hacking的时候它同样有用。
  
  持久内存的常见使用是支持持久的SQL服务连接，尽管这种做法是不赞成的，它依然是这个特性最常见的用法。
  
  Note：下面所有的函数需要额外的持续性参数，应该是false，引擎会使用它的规则的分配器(emalloc)并且内存不应该认为是持久的。
  内存作为持久化被分配的地方，系统分配器被调用，在大多数情况下它们仍然不能返回NULl指针，
  正如主要的内存APIs（内存管理基础里面介绍的APIs）。
  
   -----------------------------------------------------------------------------------------------------------------
  |                           持久内存APIs                                    
  |-------------------------------------------------------------------------------------------------------------------
  |         原型                                            描述                                                      |
  |-------------------------------------------------------------------------------------------------------------------|
  | void *pemalloc(size_t size, zend_bool persistent)               分配 size 字节的内存。                            |
  |-------------------------------------------------------------------------------------------------------------------|
  | void *pecalloc(size_t nmemb, size_t size, zend_bool persistent) 为 nmemb 元素分配 size 字节的缓冲并初始化为零。   |
  |-------------------------------------------------------------------------------------------------------------------|
  | void *perealloc(void *ptr, size_t size, zend_bool persistent)   重新调整由 emalloc 分配的，                       |
  |                                                                 大小为 size 字节的内存 ptr 缓冲大小。             |
  |-------------------------------------------------------------------------------------------------------------------|
  | void pefree(void *ptr, zend_bool persistent)                  释放 ptr 指向的缓冲区。缓冲得由 pemalloc 分配。     |
  |-------------------------------------------------------------------------------------------------------------------|
  | void *safe_pemalloc(size_t nmemb, size_t size, site_t offset, zend_bool persistent)                               |
  |                                                               分配一个用来存放每个 size 字节和                    |
  |                                                               额外 offset 字节的 nmemb 块的缓冲区。               |
  |-------------------------------------------------------------------------------------------------------------------|
  | char *pestrdup(const char *s, zend_bool persistent)     分配一个可以存放 NULL 结束字符串的缓冲区并复制到缓冲区内。|
  |-------------------------------------------------------------------------------------------------------------------|
  | char *pestrndup(const char *s, unsigned int length, zend_bool persistent)                                         |
  |                                                         当以 NULL 结束的字符串长度已经知道时，和 pestrdup 相似。  |
   -------------------------------------------------------------------------------------------------------------------
  
  Warning：重要的是记住，被分配的持久内存没有被引擎优化和追踪；它不受 memory_limit 管制，另外，Hacker 为引擎创建的所有变量
  不得使用持久内存。
  

### 线程安全资源管理器 [ Thread-Safe Resource Manager ]
  http://php.net/manual/en/internals2.memory.tsrm.php

  
