/*
|----------------------------------------
| Working with Variables
| @weiChen translate, <farwish@live.com>
| @MIT License
*/

  http://php.net/manual/zh/internals2.variables.php

### 变量介绍
  （中文doc,不完全）http://php.net/manual/zh/internals2.variables.intro.php
  http://php.net/manual/en/internals2.variables.intro.php
  
  成为一个Hacker，对变量如何储存和操作的良好理解是必要的。引擎试图掩盖变量概念的复杂性，变量可以是任何类型，
通过提供一个一致和直观的用来访问结构体各个领域的宏设置。当Hacker通过本章工作时，他们应该变得对涉及PHP中变量的术语和概念
感到舒适。

  Note: PHP是一个动态的，松散类型的语言，使用即写即拷和引用计数。
  
  要弄清上面究竟是什么意思：PHP是一个高层语言，弱类型由引擎隐式引用转换，或者强制变量转为执行类型。
引用计数意思是引擎可以推断当一个变量在用户的代码里不再有任何引用时，可以释放和这个变量相关的结构体。

  所有PHP中的变量表现为一个结构体，zval：
  
  ```
  typedef struct _zval_struct {
    zvalue_value value;         /* variable value */
    zend_uint refcount__gc;     /* reference counter */
    zend_uchar type;            /* value type */
    zend_uchar is_ref__gc;      /* reference flag */
  } zval;
  ```
  
  zval_value 是一个联合体(union)，可以代表所有类型的变量：
  
  ```
  typedef union _zvalue_value {
    long lval;          /* long value */
    double dval;        /* double value */
    struct {
      char *val;
      int len;          /* this will always be set for strings */
    } str;              /* string (always has length) */
    HashTable *ht;      /* an array */
    zend_object_value obj;  /* stores an object store handle, and handlers */
  } zvalue_value;
  ```
  
  从上面的结构体应该清楚知道一个变量可以是一种类型，变量数据由 zval_value 联合体中的合适字段表示。zval 自身保存类型，
引用计数和一个标记标示一个变量是否是一个引用。

   -------------------------------------------------
  |             原生类型常量                        |
  |-------------------------------------------------|
  | 常量                            映射            |
  |-------------------------------------------------|
  | IS_NULL                     本例中没有设置值    |
  |-------------------------------------------------|
  | IS_LONG                     lval                |
  |-------------------------------------------------|
  | IS_DOUBLE                   dval                |
  |-------------------------------------------------|
  | IS_BOOL                     lval                |
  |-------------------------------------------------|
  | IS_RESOURCE                 lval                |
  |-------------------------------------------------|
  | IS_STRING                   str                 |
  |-------------------------------------------------|
  | IS_ARRAY                    ht                  |
  |-------------------------------------------------|
  | IS_OBJECT                   obj                 |
   -------------------------------------------------
  
  Note: 额外的常量帮助指定内部类型如常量数组和可调用的对象，它们的使用在文档这部分范围之外。
  
  下面表格定义的宏由引擎暴露用来和 zval 值一起工作：
  
   ---------------------------------------------------------------------------------------------------------
  |                                     宏访问器                                                            |
  |---------------------------------------------------------------------------------------------------------|
  | 原型                                        访问器                    描述                              |
  |---------------------------------------------------------------------------------------------------------|
  | zend_uchar Z_TYPE(zval zv)                    type              返回 value 的类型                       |
  |---------------------------------------------------------------------------------------------------------|
  | long Z_LVAL(zval zv)                        value.lval                                                  |
  |---------------------------------------------------------------------------------------------------------|
  | zend_bool Z_BVAL(zval zv)                   value.lval          传递long value 到 zend_bool             |
  |---------------------------------------------------------------------------------------------------------|
  | double Z_DVAL(zval zv)                      value.dval                                                  |
  |---------------------------------------------------------------------------------------------------------|
  | long Z_RESVAL(zval zv)                      value.lval          为值返回资源列表标示符                  |
  |---------------------------------------------------------------------------------------------------------|
  | char* Z_STRVAL(zval zv)                     value.str.val       返回字符串值                            |
  |---------------------------------------------------------------------------------------------------------|
  | int Z_STRLEN(zval zv)                       value.str.len       返回字符串值的长度                      |
  |---------------------------------------------------------------------------------------------------------|
  | HashTable* Z_ARRVAL(zval zv)                value.ht            返回HashTable(array)值                  |
  |---------------------------------------------------------------------------------------------------------|
  | zend_object_value Z_OBJVAL(zval zv)         value.obj           返回对象值                              |
  |---------------------------------------------------------------------------------------------------------|
  | uint Z_OBJ_HANDLE(zval zv)                  value.obj.handle    为对象值返回资源句柄                    |
  |---------------------------------------------------------------------------------------------------------|
  | zend_object_handlers* Z_OBJ_HT_P(zval zv)   value.obj.handlers  为对象值返回处理表                      |
  |---------------------------------------------------------------------------------------------------------|
  | zend_class_entry* Z_OBJCE(zval zv)          value.obj           为对象值返回类入口                      |
  |---------------------------------------------------------------------------------------------------------|
  | HashTable* Z_OBJPROP(zval zv)               value.obj           返回对象值的属性                        |
  |---------------------------------------------------------------------------------------------------------|
  | HashTable* Z_OBJPROP(zval zv)               value.obj           返回对象值得属性                        |
  |---------------------------------------------------------------------------------------------------------|
  | HashTable* Z_OBJDEBUG(zval zv)              value.obj           如果一个对象设置了get_debug_info处理器，|
  |                                                                 它将被调用，否则 Z_OBJPROP 调用         |
   ---------------------------------------------------------------------------------------------------------
  
  引用计数和引用如何工作的详细细节请查看 引用计数基础(http://php.net/manual/en/features.gc.refcounting-basics.php)章节。
  
   -----------------------------------------------------------------------
  |                         引用计数操作                                  |
  |-----------------------------------------------------------------------|
  | 原型                                    描述                          |
  |-----------------------------------------------------------------------|
  | zend_uint Z_REFCOUNT(zval zv)           返回引用计数的值              |
  |-----------------------------------------------------------------------|
  | zend_uint Z_SET_REFCOUNT(zval zv)       设置引用计数的值，并返回      |
  |-----------------------------------------------------------------------|
  | zend_uint Z_ADDREF(zval zv)             预增量的引用计数，并返回      |
  |-----------------------------------------------------------------------|
  | zend_uint Z_DELREF(zval zv)             预减值得引用计数，并返回      |
  |-----------------------------------------------------------------------|
  | zend_bool Z_ISREF(zval zv)              检测 zval 是否是一个引用      |
  |-----------------------------------------------------------------------|
  | void Z_UNSET_ISREF(zval zv)             设置 is_ref__gc 为0           |
  |-----------------------------------------------------------------------|
  | void Z_SET_ISREF(zval zv)               设置 is_ref__gc 为1           |
  |-----------------------------------------------------------------------|
  | void Z_SET_ISREF_TO(zval zv, zend_uchar to) 设置 is_ref__gc 为 to     |
   -----------------------------------------------------------------------
   
  Note: 上面的Z_*的宏都带有一个zval，它们都由_P作为后缀重新定义来带有一个指向zval的宏，
  如 zend_uchar Z_TYPE_P(zval* pzv)，并且再一次以_PP为后缀带有指向zval的指针，如 zend_uchar Z_TYPE_PP(zval** ppzv)
  
   -----------------------------------------------------------------------------------------------------------
  |                   创建，描述，分离和复制                                                                  |
  |-----------------------------------------------------------------------------------------------------------|
  | 原型                                描述                                                                  |
  |-----------------------------------------------------------------------------------------------------------|
  | ALLOC_ZVAL(zval* pzval)             分配内存 pzval                                                        |
  |-----------------------------------------------------------------------------------------------------------|
  | ALLOC_INIT_ZVAL(zval* pzval)        分配内存 pzval, 并把pzval的指针指向null类型的zval                     |
  |-----------------------------------------------------------------------------------------------------------|
  | MAKE_STD_ZVAL(zval* pzval)          分配内存 pzval, 设置引用计数为1                                       |
  |-----------------------------------------------------------------------------------------------------------|
  | ZVAL_COPY_VALUE(zval* dst, zval* src)   用 src 的值和类型设置 dst 的值和类型                              |
  |-----------------------------------------------------------------------------------------------------------|
  | INIT_PZVAL_COPY(zval* dst, zval* dst)   执行 ZVAL_COPY_VALUE，设置 dst 引用计数为1，设置 is_ref__gc 为0   |
  |-----------------------------------------------------------------------------------------------------------|
  | SEPARATE_ZVAL(zval** ppzval)            如果 ppzval 的引用计数 > 1，重新分配 *ppzval 到一个新的内存分配， |
  |                                         副本，和构造相同类型和值的 zval                                   |
  |-----------------------------------------------------------------------------------------------------------|
  | SEPARATE_ZVAL_IF_NOT_REF(zval** ppzval) 如果 *ppzval 不是一个引用，在 ppzval 上执行 SEPARATE_ZVAL         |
  |-----------------------------------------------------------------------------------------------------------|
  | SEPARATE_ZVAL_TO_MAKE_IS_REF(zval** ppzval) 如果 *ppzval 不是一个引用，在 ppzval 上执行 SEPARATE_ZVAL     |
  |                                             接着 Z_SET_ISREF_PP                                           |
  |-----------------------------------------------------------------------------------------------------------|
  | COPY_PZVAL_TO_ZVAL(zval dst, zval** src)    不影响 src 的引用计数的情况下把 dst 变成 src 的一个副本       |
  |-----------------------------------------------------------------------------------------------------------|
  | MAKE_COPY_ZVAL(zval** src, zval* dst)       执行 INIT_PZVAL_COPY，接着是新zval上的 zval_copy_ctor         |
  |-----------------------------------------------------------------------------------------------------------|
  | void zval_copy_ctor(zval** pzval)           执行引用计数保持，广泛使用在整个引擎中                        |
  |-----------------------------------------------------------------------------------------------------------|
  | void zval_ptr_dtor(zval* pzval)             递减变量的引用计数，如果没有引用计数就销毁变量                |
  |-----------------------------------------------------------------------------------------------------------|
  | FREE_ZVAL(zval* pzval)                      释放 pzval                                                    |
   -----------------------------------------------------------------------------------------------------------

  Note：对象和资源有一个引用计数作为它们各自结构体的一部分，当 zval_ptr_dtor 没有被两者调用，它们的相关的 del_ref 方法
  执行。更多信息查看Working with Objects 和 Working with Resources。
  
  如果一个Hacker只能记住两个方法，它们应该是 zval_copy_ctor 和 zval_ptr_dtor，这些是引擎引用计数机制的基础，
并且重要的是记住 zval_copy_ctor 实际在正常情况不会发生任何复制，它简单提高引用数量。通过相同的token，只有当没有引用时
zval_ptr_dtor 才实际销毁一个变量并且引用计数为0。

  PHP是弱类型的，如引擎为转换变量的类型到另一个类型提供了API函数。
  
   -----------------------------------------------------------------------
  |                               类型转换                                |
  |-----------------------------------------------------------------------|
  | 原型                                                                  |
  |-----------------------------------------------------------------------|
  | void convert_to_long(zval* pzval)                                     |
  |-----------------------------------------------------------------------|
  | void convert_to_double(zval* pzval)                                   |
  |-----------------------------------------------------------------------|
  | void convert_to_long_base(zval* pzval, int base)                      |
  |-----------------------------------------------------------------------|
  | void convert_to_null(zval* pzval)                                     |
  |-----------------------------------------------------------------------|
  | void convert_to_boolean(zval* pzval)                                  |
  |-----------------------------------------------------------------------|
  | void convert_to_array(zval* pzval)                                    |
  |-----------------------------------------------------------------------|
  | void convert_to_object(zval* pzval)                                   |
  |-----------------------------------------------------------------------|
  | void convert_object_to_type(zval* pzval, convert_func_t converter)    |
   -----------------------------------------------------------------------
   
  Note：convert_func_t 函数应该有原型 (void) (zval* pzval)
  
  到现在你应该有一个良好的理解：引擎的本地变量如何发现类型和读取 zval 值，如何操作引用计数，和其它 zval 标示。
